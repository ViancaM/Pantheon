<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pantheon - Card Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --dark: #0a0a1a;
            --light: #e2e8ff;
            --accent: #a8c0ff;
            --earth: #8B4513;
            --air: #4682B4;
            --fire: #DC143C;
            --water: #1E90FF;
            --retrograde: #6a3093;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: var(--dark);
            color: var(--light);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }
        
        .space-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(80, 60, 180, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(60, 80, 200, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 40, 200, 0.2) 0%, transparent 50%),
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100%25' height='100%25'%3E%3Cdefs%3E%3Cpattern id='stars' width='150' height='150' patternUnits='userSpaceOnUse'%3E%3Ccircle cx='20' cy='20' r='1' fill='%23ffffff' opacity='0.9'/%3E%3Ccircle cx='80' cy='40' r='0.8' fill='%23ffffff' opacity='0.8'/%3E%3Ccircle cx='40' cy='80' r='1.2' fill='%23ffffff' opacity='0.7'/%3E%3Ccircle cx='100' cy='100' r='0.6' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='60' cy='30' r='0.9' fill='%23ffffff' opacity='0.8'/%3E%3Ccircle cx='30' cy='60' r='1.1' fill='%23ffffff' opacity='0.7'/%3E%3Ccircle cx='90' cy='70' r='0.7' fill='%23ffffff' opacity='0.9'/%3E%3Ccircle cx='50' cy='110' r='1' fill='%23ffffff' opacity='0.6'/%3E%3Ccircle cx='110' cy='20' r='0.8' fill='%23ffffff' opacity='0.8'/%3E%3Ccircle cx='70' cy='90' r='1.3' fill='%23ffffff' opacity='0.7'/%3E%3Ccircle cx='120' cy='50' r='0.5' fill='%23ffffff' opacity='0.9'/%3E%3Ccircle cx='10' cy='100' r='1' fill='%23ffffff' opacity='0.6'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23stars)'/%3E%3C/svg%3E");
            z-index: -1;
        }
        
        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(10, 10, 25, 0.8);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 200, 0.3);
            position: relative;
        }
        
        .hamburger-menu {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .hamburger-menu:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-50%) scale(1.05);
        }
        
        .hamburger-menu .bar {
            width: 25px;
            height: 3px;
            background: var(--accent);
            margin: 4px 0;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .menu {
            position: absolute;
            left: 20px;
            top: 80px;
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid rgba(100, 100, 200, 0.3);
            border-radius: 8px;
            padding: 10px;
            min-width: 150px;
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1000;
        }
        
        .menu.active {
            display: block;
        }
        
        .menu-item {
            padding: 10px 15px;
            color: var(--light);
            text-decoration: none;
            display: block;
            border-radius: 5px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent);
        }
        
        .game-title {
            font-size: 3.5rem;
            background: linear-gradient(135deg, var(--accent) 0%, #c2a8ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(168, 192, 255, 0.3);
        }
        
        .game-subtitle {
            font-size: 1.2rem;
            color: var(--accent);
            margin-bottom: 20px;
        }
        
        .game-board {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            height: calc(100vh - 200px);
        }
        
        .turn-indicator {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            font-size: 1.3rem;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 200, 0.3);
            max-width: 400px;
            margin: 0 auto;
        }
        
        .current-turn {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .players-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .player-area {
            padding: 20px;
            border-radius: 15px;
            background: rgba(40, 40, 80, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(100, 100, 200, 0.3);
            display: flex;
            flex-direction: column;
        }
        
        .player-1 {
            border-color: #4CAF50;
        }
        
        .player-2 {
            border-color: #FF5722;
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--light);
        }
        
        .player-stats {
            display: flex;
            gap: 15px;
        }
        
        .stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        .cards-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-grow: 1;
        }
        
        .cards-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }
        
        .section-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .cards-grid {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            min-height: 180px;
        }
        
        .card {
            width: 180px;
            height: 300px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .card.earth {
            background: linear-gradient(135deg, var(--earth) 0%, #A0522D 100%);
        }
        
        .card.air {
            background: linear-gradient(135deg, var(--air) 0%, #87CEEB 100%);
        }
        
        .card.fire {
            background: linear-gradient(135deg, var(--fire) 0%, #FF4500 100%);
        }
        
        .card.water {
            background: linear-gradient(135deg, var(--water) 0%, #00008B 100%);
        }
        
        .card.retrograde {
            background: linear-gradient(135deg, var(--retrograde) 0%, #a044ff 100%);
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
        }
        
        .card.selected {
            border: 3px solid #FFD700;
            box-shadow: 0 0 15px #FFD700;
            transform: scale(1.05);
        }
        
        .card.completed {
            border: 2px solid #4CAF50;
        }
        
        .card.hidden {
            background-image: url('images/card_back.png');
            background-size: cover;
            background-position: center;
        }
        
        .card.hidden .card-element,
        .card.hidden .card-name,
        .card.hidden .card-content {
            visibility: hidden;
        }

        .card.retrograde.hidden {
            background-image: url('images/card_back.png') !important;
        }

        .card-element {
            font-size: 0.8rem;
            padding: 3px 10px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.2);
            margin-bottom: 8px;
        }
        
        .card-name {
            font-size: 1rem;
            margin: 8px 0;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .card-content {
            font-size: 0.75rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 100%;
            gap: 8px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
        }
        
        .card-challenge, .card-disadvantage {
            margin: 0;
            font-weight: normal;
            text-align: left;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 6px;
            line-height: 1.4;
            min-height: 40px;
        }
        
        .card-challenge::before {
            content: "Challenge: ";
            font-weight: bold;
            color: #a8ffa8;
        }
        
        .card-disadvantage::before {
            content: "Disadvantage: ";
            font-weight: bold;
            color: #ffa8a8;
        }
        
        .game-controls {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
        }
        
        .player-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            color: white;
        }
        
        .deck-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 200, 0.3);
        }
        
        .deck-card {
            width: 120px;
            height: 168px;
            background-image: url('images/card_back.png');
            background-size: cover;
            background-position: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }
        
        .deck-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .deck-stats {
            color: var(--accent);
            font-size: 1rem;
        }
        
        .action-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 12px;
            padding: 20px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 3000;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid rgba(100, 100, 200, 0.3);
            border-radius: 15px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(15px);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(100, 100, 200, 0.3);
        }
        
        .modal-title {
            color: var(--light);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close-modal:hover {
            color: var(--light);
        }
        
        .help-section {
            margin-bottom: 1.5rem;
        }
        
        .help-section h3 {
            color: var(--light);
            margin-bottom: 0.8rem;
            font-size: 1.2rem;
        }
        
        .help-section p {
            color: var(--accent);
            line-height: 1.6;
            margin-bottom: 0.8rem;
        }
        
        .help-section ul {
            color: var(--accent);
            padding-left: 1.5rem;
            margin-bottom: 0.8rem;
        }
        
        .help-section li {
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }
        
        .help-section strong {
            color: var(--light);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-label {
            color: var(--accent);
            font-weight: 500;
            display: block;
            margin-bottom: 0.5rem;
        }
        
        .form-range {
            width: 100%;
        }
        
        .form-control {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--light);
            border-radius: 8px;
            padding: 10px;
            width: 100%;
        }
        
        .btn-saved {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important;
            transform: scale(0.95);
        }
        
        @media (max-width: 1200px) {
            .players-container {
                grid-template-columns: 1fr;
            }
            
            .game-board {
                height: auto;
            }
        }
        
        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem;
            }
            
            .card {
                width: 140px;
                height: 200px;
            }
            
            .player-controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .game-controls {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .deck-area {
                order: -1;
            }
            
            .hamburger-menu {
                left: 10px;
                padding: 8px;
            }
            
            .menu {
                left: 10px;
                top: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="space-bg"></div>
    
    <div class="game-container">
        <header class="game-header">
            <!-- Hamburger Menu -->
            <div class="hamburger-menu" id="hamburger-menu">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>
            <div class="menu" id="menu">
                <a class="menu-item" id="menu-home">Home</a>
                <a class="menu-item" id="menu-settings">Settings</a>
                <a class="menu-item" id="menu-help">How to Play</a>
            </div>
            
            <h1 class="game-title">PANTHEON</h1>
            <p class="game-subtitle">A Celestial Card Game of Strategy and Skill</p>
        </header>
        
        <div class="game-board">
            <div class="turn-indicator">
                Current Turn: <span class="current-turn" id="current-player">Player 1</span>
            </div>
            
            <div class="players-container">
                <!-- Player 2 Area -->
                <div class="player-area player-2">
                    <div class="player-header">
                        <h2 class="player-name">Player 2</h2>
                        <div class="player-stats">
                            <div class="stat">Active: <span id="player2-active-count">3</span></div>
                            <div class="stat">Completed: <span id="player2-completed-count">0</span></div>
                        </div>
                    </div>
                    
                    <div class="cards-container">
                        <div class="cards-section">
                            <h3 class="section-title">Active Cards</h3>
                            <div class="cards-grid" id="player2-active">
                                <!-- Player 2 active cards will be populated here -->
                            </div>
                        </div>
                        
                        <div class="cards-section">
                            <h3 class="section-title">Completed Cards</h3>
                            <div class="cards-grid" id="player2-completed">
                                <!-- Player 2 completed cards will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Player 1 Area -->
                <div class="player-area player-1">
                    <div class="player-header">
                        <h2 class="player-name">Player 1</h2>
                        <div class="player-stats">
                            <div class="stat">Active: <span id="player1-active-count">3</span></div>
                            <div class="stat">Completed: <span id="player1-completed-count">0</span></div>
                        </div>
                    </div>
                    
                    <div class="cards-container">
                        <div class="cards-section">
                            <h3 class="section-title">Active Cards</h3>
                            <div class="cards-grid" id="player1-active">
                                <!-- Player 1 active cards will be populated here -->
                            </div>
                        </div>
                        
                        <div class="cards-section">
                            <h3 class="section-title">Completed Cards</h3>
                            <div class="cards-grid" id="player1-completed">
                                <!-- Player 1 completed cards will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-controls">
                <!-- Player 2 Controls -->
                <div class="player-controls">
                    <button class="btn btn-primary" data-player="2" id="attempt-challenge-2">
                        <i class="fas fa-bolt"></i> Attempt Challenge
                    </button>
                    <button class="btn btn-primary" data-player="2" id="draw-card-2">
                        <i class="fas fa-sync"></i> Forsake & Draw
                    </button>
                    <button class="btn btn-primary" data-player="2" id="trade-2">
                        <i class="fas fa-exchange-alt"></i> Trade
                    </button>
                    <button class="btn btn-warning" data-player="2" id="retrograde-2">
                        <i class="fas fa-undo"></i> Use Retrograde
                    </button>
                    <button class="btn btn-secondary" data-player="2" id="skip-turn-2">
                        <i class="fas fa-forward"></i> Skip Turn
                    </button>
                </div>
                
                <!-- Deck Area -->
                <div class="deck-area">
                    <h3>Deck</h3>
                    <div class="deck-card" id="deck-card">
                        <!-- Deck card visual -->
                    </div>
                    <div class="deck-stats">
                        Cards remaining: <span id="deck-count">26</span>
                    </div>
                </div>
                
                <!-- Player 1 Controls -->
                <div class="player-controls">
                    <button class="btn btn-primary" data-player="1" id="attempt-challenge-1">
                        <i class="fas fa-bolt"></i> Attempt Challenge
                    </button>
                    <button class="btn btn-primary" data-player="1" id="draw-card-1">
                        <i class="fas fa-sync"></i> Forsake & Draw
                    </button>
                    <button class="btn btn-primary" data-player="1" id="trade-1">
                        <i class="fas fa-exchange-alt"></i> Trade
                    </button>
                    <button class="btn btn-warning" data-player="1" id="retrograde-1">
                        <i class="fas fa-undo"></i> Use Retrograde
                    </button>
                    <button class="btn btn-secondary" data-player="1" id="skip-turn-1">
                        <i class="fas fa-forward"></i> Skip Turn
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Action Feedback -->
    <div class="action-feedback" id="action-feedback"></div>
    
    <!-- Game Modals -->
    <div class="modal-overlay" id="game-settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Game Settings</h2>
                <button class="close-modal" id="close-settings">&times;</button>
            </div>
            <form id="game-settings-form">
                <div class="form-group">
                    <label class="form-label">Music Volume: <span id="game-music-display">50%</span></label>
                    <input type="range" class="form-range" id="game-music-volume" min="0" max="100" value="50">
                </div>
                <div class="form-group">
                    <label class="form-label">Sound Effects: <span id="game-sfx-display">70%</span></label>
                    <input type="range" class="form-range" id="game-sfx-volume" min="0" max="100" value="70">
                </div>
                <div class="text-center">
                    <button type="submit" class="btn btn-primary" id="game-save-settings">Save Settings</button>
                </div>
            </form>
        </div>
    </div>
    
    <div class="modal-overlay" id="game-help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">How to Play Pantheon</h2>
                <button class="close-modal" id="close-help">&times;</button>
            </div>
            
            <div class="help-section">
                <h3>Game Objective</h3>
                <p>Be the first player to complete three cards that all share the same element.</p>
            </div>

            <div class="help-section">
                <h3>Setup</h3>
                <ul>
                    <li>Shuffle all 26 cards (24 Zodiac + 2 Retrograde)</li>
                    <li>Each player draws 3 Active Cards</li>
                </ul>
            </div>

            <div class="help-section">
                <h3>Turn Actions</h3>
                <ul>
                    <li><strong>Attempt Challenge:</strong> Try to complete an Active Card's challenge. If successful, move it to Completed. If failed, apply its disadvantage.</li>
                    <li><strong>Forsake & Draw:</strong> Discard an Active Card and draw a new one from the deck.</li>
                    <li><strong>Trade:</strong> Exchange cards with another player.</li>
                    <li><strong>Skip Turn:</strong> Pass your turn (cannot skip twice in a row).</li>
                </ul>
            </div>

            <div class="help-section">
                <h3>Retrograde Cards</h3>
                <p>Once per game, you can use a Retrograde card to return all completed cards to the deck. This can create dramatic comebacks!</p>
            </div>

            <div class="help-section">
                <h3>Winning the Game</h3>
                <p>The first player to complete three cards of the same element immediately wins the game!</p>
            </div>

            <div class="text-center mt-4">
                <button class="btn btn-primary" id="close-help-btn">Got It!</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="winner-modal">
        <div class="modal-content">
            <h2 class="text-center mb-4" id="winner-text" style="color:#e2e8ff;">Player X Wins!</h2>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button class="btn btn-primary" id="rematch-btn">Rematch</button>
                <button class="btn btn-secondary" id="main-menu-btn">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="trade-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="trade-modal-title">Trade Offer</h2>
                <button class="close-modal" id="close-trade-modal">&times;</button>
            </div>
            <div class="text-center">
                <h3>Offered Card:</h3>
                <div id="trade-offer-area" style="display: flex; justify-content: center; margin: 20px 0;"></div>
                
                <div id="trade-select-responder" style="display: none;">
                    <h3>Select a card to trade back:</h3>
                    <div id="trade-responder-cards" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin: 20px 0;"></div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="btn btn-primary" id="trade-accept-btn">Accept Trade</button>
                    <button class="btn btn-secondary" id="trade-decline-btn">Decline</button>
                    <button class="btn btn-secondary" id="trade-cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Challenge target modal -->
    <div class="modal-overlay" id="challenge-target-modal">
        <div class="modal-content">
            <button class="close-modal" id="close-challenge-target">&times;</button>
            <h2 class="text-center">Select Challenge Target</h2>
            <div id="challenge-target-cards"></div>
            <div style="text-align:center; margin-top:8px;">
                <button id="cancel-challenge-target">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Complete card data
        const allCards = [
            {
                id: 1,
                name: "Capricorn",
                element: "earth",
                challenge: "Gain a new Earth sign or forsake a Fire sign.",
                disadvantage: "Must complete challenge by next turn. Otherwise forsake this card."
            },
            {
                id: 2,
                name: "Taurus",
                element: "earth",
                challenge: "Avoid all trades and retrogrades until your next turn.",
                disadvantage: "If any card is lost, forsake this card."
            },
            {
                id: 3,
                name: "Virgo",
                element: "earth",
                challenge: "Forsake the two active cards and redraw two new cards.",
                disadvantage: "If both of the drawn cards match elements from the discarded cards, forsake one completed card."
            },
            {
                id: 4,
                name: "Aries",
                element: "fire",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 5,
                name: "Gemini",
                element: "air",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 6,
                name: "Sagittarius",
                element: "fire",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 7,
                name: "Libra",
                element: "air",
                challenge: "Have at least one of each element in your active or completed hand.",
                disadvantage: "If your total card count is less than 4, forsake this card."
            },
            {
                id: 8,
                name: "Aquarius",
                element: "air",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 9,
                name: "Pisces",
                element: "water",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 10,
                name: "Scorpio",
                element: "water",
                challenge: "Complete any active cards challenge.",
                disadvantage: "If your opponent completes a challenge while this card is being attempted, forsake this card only."
            },
            {
                id: 11,
                name: "Cancer",
                element: "water",
                challenge: "Offer one of your active cards to your opponent.",
                disadvantage: "If they refuse the trade, forsake this card."
            },
            {
                id: 12,
                name: "Leo",
                element: "fire",
                challenge: "Correctly predict the next element in the pile before the next card is pulled.",
                disadvantage: "If incorrect, any matching element in your active hand must be forsaken."
            },
            {
                id: 13,
                name: "Aries",
                element: "fire",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 14,
                name: "Leo",
                element: "fire",
                challenge: "Correctly predict the next element in the pile before the next card is pulled.",
                disadvantage: "If incorrect, any matching element in your active hand must be forsaken."
            },
            {
                id: 15,
                name: "Sagittarius",
                element: "fire",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 16,
                name: "Scorpio",
                element: "water",
                challenge: "Complete any active cards challenge.",
                disadvantage: "If your opponent completes a challenge while this card is active, forsake this card."
            },
            {
                id: 17,
                name: "Gemini",
                element: "air",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 18,
                name: "Libra",
                element: "air",
                challenge: "Have at least one of each element in your active or completed hand.",
                disadvantage: "If your total card count is less than 4, forsake this card."
            },
            {
                id: 19,
                name: "Cancer",
                element: "water",
                challenge: "Offer one of your active cards to your opponent.",
                disadvantage: "If they refuse the trade, forsake this card."
            },
            {
                id: 20,
                name: "Scorpio",
                element: "water",
                challenge: "Complete any active cards challenge.",
                disadvantage: "If your opponent completes a challenge while this card is active, forsake this card."
            },
            {
                id: 21,
                name: "Pisces",
                element: "water",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 22,
                name: "Aquarius",
                element: "air",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 23,
                name: "Virgo",
                element: "earth",
                challenge: "Forsake the other active cards and redraw two new cards.",
                disadvantage: "If both of the drawn cards match elements from the previous hand, forsake one completed card."
            },
            {
                id: 24,
                name: "Taurus",
                element: "earth",
                challenge: "Avoid all trades and retrogrades until your next turn.",
                disadvantage: "If any card is lost, forsake this card."
            },
            {
                id: 25,
                name: "Retrograde",
                element: "retrograde",
                challenge: "",
                disadvantage: ""
            },
            {
                id: 26,
                name: "Retrograde",
                element: "retrograde",
                challenge: "",
                disadvantage: ""
            },
        ];

        // Game state
        let gameState;
        let challengeSourceCard = null;
        let virgoState = null;

        // Utility functions
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function refillToThree(state, playerId) {
            const player = state.players[playerId];
            const currentCardNames = new Set(player.activeCards.map(c => c.name));

            while (player.activeCards.length < 3 && (state.deck.length > 0 || state.discardPile.length > 0)) {
                if (state.deck.length === 0) {
                    reshuffleDiscardIntoDeck(state);
                }
                if (state.deck.length === 0) break;

                const newCard = state.deck.pop();

                if (!currentCardNames.has(newCard.name)) {
                    player.activeCards.push(newCard);
                    currentCardNames.add(newCard.name);
                } else {
                    state.discardPile.push(newCard);
                }
            }
            updatePlayerCounts();
        }

        function reshuffleDiscardIntoDeck(state) {
            if (state.discardPile.length === 0) return;
            state.deck.push(...state.discardPile);
            state.discardPile = [];
            shuffleDeck(state.deck);
        }

        function showActionFeedback(message, isSuccess = true) {
            const feedback = document.getElementById('action-feedback');
            feedback.textContent = message;
            feedback.style.borderColor = isSuccess ? '#4CAF50' : '#FF5722';
            feedback.style.display = 'block';

            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1800);
        }

        function updatePlayerCounts() {
            document.getElementById('player1-active-count').textContent = gameState.players[1].activeCards.length;
            document.getElementById('player1-completed-count').textContent = gameState.players[1].completedCards.length;
            document.getElementById('player2-active-count').textContent = gameState.players[2].activeCards.length;
            document.getElementById('player2-completed-count').textContent = gameState.players[2].completedCards.length;
        }

        // Initialize the game
        function initializeGame() {
            gameState = {
                currentPlayer: 1,
                players: {
                    1: { 
                        activeCards: [], 
                        completedCards: [], 
                        usedRetrograde: false,
                        selectedCard: null,
                        skipNextTurn: false,
                        taurusPending: false,
                        taurusPendingId: null,
                        taurusSnapshot: null
                    },
                    2: { 
                        activeCards: [], 
                        completedCards: [], 
                        usedRetrograde: false,
                        selectedCard: null,
                        skipNextTurn: false,
                        taurusPending: false,
                        taurusPendingId: null,
                        taurusSnapshot: null
                    }
                },
                deck: [...allCards],
                discardPile: [],
                tradeOffer: null
            };

            // Remove duplicate cards from initial deal
            const usedCardIds = new Set();
            shuffleDeck(gameState.deck);

            // Deal initial cards ensuring no duplicates
            for (let i = 0; i < 3; i++) {
                if (gameState.deck.length > 0) {
                    const card = gameState.deck.pop();
                    if (!usedCardIds.has(card.id)) {
                        gameState.players[1].activeCards.push(card);
                        usedCardIds.add(card.id);
                    }
                }
                if (gameState.deck.length > 0) {
                    const card = gameState.deck.pop();
                    if (!usedCardIds.has(card.id)) {
                        gameState.players[2].activeCards.push(card);
                        usedCardIds.add(card.id);
                    }
                }
            }
            updateGameDisplay();
            setupEventListeners();
        }

        function setupEventListeners() {
            // Player 1 controls
            document.getElementById('attempt-challenge-1').addEventListener('click', function() { attemptChallenge(1); });
            document.getElementById('draw-card-1').addEventListener('click', function() { forsakeAndDraw(1); });
            document.getElementById('trade-1').addEventListener('click', function() { initiateTrade(1); });
            document.getElementById('retrograde-1').addEventListener('click', function() { useRetrograde(1); });
            document.getElementById('skip-turn-1').addEventListener('click', function() { skipTurn(1); });

            // Player 2 controls  
            document.getElementById('attempt-challenge-2').addEventListener('click', function() { attemptChallenge(2); });
            document.getElementById('draw-card-2').addEventListener('click', function() { forsakeAndDraw(2); });
            document.getElementById('trade-2').addEventListener('click', function() { initiateTrade(2); });
            document.getElementById('retrograde-2').addEventListener('click', function() { useRetrograde(2); });
            document.getElementById('skip-turn-2').addEventListener('click', function() { skipTurn(2); });

            // Common controls
            document.getElementById('deck-card').addEventListener('click', drawFromDeck);

            // Modal controls
            document.getElementById('close-trade-modal').addEventListener('click', closeTradeModal);
            document.getElementById('trade-cancel-btn').addEventListener('click', cancelTrade);
            document.getElementById('trade-accept-btn').addEventListener('click', tradeAcceptHandler);
            document.getElementById('trade-decline-btn').addEventListener('click', tradeDeclineHandler);

            document.getElementById('close-challenge-target').addEventListener('click', closeChallengeTargetModal);
            document.getElementById('cancel-challenge-target').addEventListener('click', closeChallengeTargetModal);

            document.getElementById('rematch-btn').addEventListener('click', function() {
                document.getElementById('winner-modal').style.display = 'none';
                initializeGame();
            });

            // Hamburger menu - REMOVE THIS LINE
            // initializeHamburgerMenu();
        }
        
        function initializeHamburgerMenu() {    
            const hamburgerMenu = document.getElementById('hamburger-menu');
            const menu = document.getElementById('menu');
            const menuHome = document.getElementById('menu-home');
            const menuSettings = document.getElementById('menu-settings');
            const menuHelp = document.getElementById('menu-help');

            const settingsModal = document.getElementById('game-settings-modal');
            const helpModal = document.getElementById('game-help-modal');

            const closeSettings = document.getElementById('close-settings');
            const closeHelp = document.getElementById('close-help');
            const closeHelpBtn = document.getElementById('close-help-btn');

            const gameSettingsForm = document.getElementById('game-settings-form');
            const gameSaveSettingsBtn = document.getElementById('game-save-settings');

            // Toggle menu when hamburger is clicked
            hamburgerMenu.addEventListener('click', function(e) {
                e.stopPropagation();
                menu.classList.toggle('active');
            });

            // Close menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!menu.contains(e.target) && !hamburgerMenu.contains(e.target)) {
                    menu.classList.remove('active');
                }
            });

            // Menu item click handlers
            menuHome.addEventListener('click', function(e) {
                e.preventDefault();
                window.location.href = "index.html";
                menu.classList.remove('active');
            });

            menuSettings.addEventListener('click', function() {
                loadGameSettings();
                settingsModal.style.display = 'block';
                menu.classList.remove('active');
            });

            menuHelp.addEventListener('click', function() {
                helpModal.style.display = 'block';
                menu.classList.remove('active');
            });

            // Modal close handlers
            closeSettings.addEventListener('click', function() {
                settingsModal.style.display = 'none';
            });

            gameSettingsForm.addEventListener('submit', function(e) {
                e.preventDefault();
                saveGameSettings();
                gameSaveSettingsBtn.classList.add('btn-saved');
                gameSaveSettingsBtn.textContent = 'âœ“ Saved!';
                setTimeout(() => {
                    gameSaveSettingsBtn.classList.remove('btn-saved');
                    gameSaveSettingsBtn.textContent = 'Save Settings';
                    settingsModal.style.display = 'none';
                }, 1000);
            });

            closeHelp.addEventListener('click', function() {
                helpModal.style.display = 'none';
            });

            closeHelpBtn.addEventListener('click', function() {
                helpModal.style.display = 'none';
            });

            window.addEventListener('click', function(e) {
                if (e.target === settingsModal) {
                    settingsModal.style.display = 'none';
                }
                if (e.target === helpModal) {
                    helpModal.style.display = 'none';
                }
            });

            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    settingsModal.style.display = 'none';
                    helpModal.style.display = 'none';
                    menu.classList.remove('active');
                }
            });

            document.getElementById('game-music-volume').addEventListener('input', function() {
                document.getElementById('game-music-display').textContent = this.value + '%';
            });

            document.getElementById('game-sfx-volume').addEventListener('input', function() {
                document.getElementById('game-sfx-display').textContent = this.value + '%';
            });
        }

        function loadGameSettings() {
            // Load settings from localStorage if available
            const savedMusicVolume = localStorage.getItem('pantheonMusicVolume');
            const savedSfxVolume = localStorage.getItem('pantheonSfxVolume');
            
            if (savedMusicVolume) {
                document.getElementById('game-music-volume').value = savedMusicVolume;
                document.getElementById('game-music-display').textContent = savedMusicVolume + '%';
            }
            
            if (savedSfxVolume) {
                document.getElementById('game-sfx-volume').value = savedSfxVolume;
                document.getElementById('game-sfx-display').textContent = savedSfxVolume + '%';
            }
        }

        function saveGameSettings() {
            // Save settings to localStorage
            const musicVolume = document.getElementById('game-music-volume').value;
            const sfxVolume = document.getElementById('game-sfx-volume').value;
            
            localStorage.setItem('pantheonMusicVolume', musicVolume);
            localStorage.setItem('pantheonSfxVolume', sfxVolume);
        }

        function createCardElement(card, isCompleted = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.element} ${isCompleted ? 'completed' : ''}`;
            
            if (card.element === 'retrograde') {
                cardDiv.style.backgroundImage = "url('images/retrograde.png')";
                cardDiv.style.backgroundSize = "100% 100%";
                cardDiv.style.backgroundPosition = "center";
                cardDiv.style.backgroundRepeat = "no-repeat";
                cardDiv.innerHTML = ''; // Clear any inner content
            } else {
                cardDiv.innerHTML = `
                    <div class="card-element">${card.element.toUpperCase()}</div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-content">
                        ${card.challenge && card.challenge.trim() !== "" ? `<div class="card-challenge">${card.challenge}</div>` : ''}
                        ${card.disadvantage && card.disadvantage.trim() !== "" ? `<div class="card-disadvantage">${card.disadvantage}</div>` : ''}
                        ${(!card.challenge || card.challenge.trim() === "") && (!card.disadvantage || card.disadvantage.trim() === "") ? 
                            '<div style="text-align: center; font-style: italic; color: #a8c0ff;">Auto-complete when attempted</div>' : ''}
                    </div>
                `;
            }

            cardDiv.addEventListener('click', function(e) {
                const tradeModal = document.getElementById('trade-modal');
                const tradeSelectResponder = document.getElementById('trade-select-responder');
                const challengeTargetModal = document.getElementById('challenge-target-modal');

                if (tradeModal && tradeModal.style.display === 'block' && tradeSelectResponder.style.display === 'block') {
                    return;
                }

                if (challengeTargetModal && challengeTargetModal.style.display === 'block') {
                    handleChallengeTargetSelection(card);
                    return;
                }

                let parent = e.currentTarget.parentElement;
                if (!parent) return;
                if (parent.id === 'player1-active') selectCard(card, 1);
                if (parent.id === 'player2-active') selectCard(card, 2);
            });
            
            return cardDiv;
        }

        function selectCard(card, playerId) {
            if (playerId !== gameState.currentPlayer) return;

            const player = gameState.players[playerId];
            if (player.selectedCard && player.selectedCard.id === card.id) {
                player.selectedCard = null;
            } else {
                player.selectedCard = card;
            }
            updateGameDisplay();
        }

        function updateGameDisplay() {
            if (!gameState) return;

            document.getElementById('current-player').textContent = `Player ${gameState.currentPlayer}`;

            // Update player 1 display
            const player1Active = document.getElementById('player1-active');
            const player1Completed = document.getElementById('player1-completed');
            player1Active.innerHTML = '';
            player1Completed.innerHTML = '';

            gameState.players[1].activeCards.forEach(card => {
                const el = createCardElement(card);
                if (gameState.currentPlayer === 2) el.classList.add('hidden');
                if (gameState.players[1].selectedCard && gameState.players[1].selectedCard.id === card.id) el.classList.add('selected');
                player1Active.appendChild(el);
            });

            gameState.players[1].completedCards.forEach(card => {
                player1Completed.appendChild(createCardElement(card, true));
            });

            // Update player 2 display
            const player2Active = document.getElementById('player2-active');
            const player2Completed = document.getElementById('player2-completed');
            player2Active.innerHTML = '';
            player2Completed.innerHTML = '';

            gameState.players[2].activeCards.forEach(card => {
                const el = createCardElement(card);
                if (gameState.currentPlayer === 1) el.classList.add('hidden');
                if (gameState.players[2].selectedCard && gameState.players[2].selectedCard.id === card.id) el.classList.add('selected');
                player2Active.appendChild(el);
            });

            gameState.players[2].completedCards.forEach(card => {
                player2Completed.appendChild(createCardElement(card, true));
            });

            document.getElementById('deck-count').textContent = gameState.deck.length;

            // Update retrograde button states
            document.getElementById('retrograde-1').disabled = gameState.players[1].usedRetrograde;
            document.getElementById('retrograde-2').disabled = gameState.players[2].usedRetrograde;

            updatePlayerCounts();
        }

        function forceForsakeCardById(playerId, cardId, reason) {
            const player = gameState.players[playerId];
            let removed = false;

            // Active
            if (player.activeCards.find(c => c.id === cardId)) {
                player.activeCards = player.activeCards.filter(c => c.id !== cardId);
                removed = true;
            }
            // Completed
            if (player.completedCards.find(c => c.id === cardId)) {
                player.completedCards = player.completedCards.filter(c => c.id !== cardId);
                removed = true;
            }

            if (removed) {
                const cardObj = allCards.find(c => c.id === cardId) || { id: cardId, name: 'Unknown' };
                gameState.discardPile.push(cardObj);
                showActionFeedback(`Card forsaken${reason ? `: ${reason}` : ''}`, false);
            }
        }

        function resolveTaurusAfterCardChange(playerId) {
            const player = gameState.players[playerId];
            if (!player.taurusPending || !player.taurusPendingId || !player.taurusSnapshot) return;

            const currentSnapshot = {
                active: player.activeCards.map(c => c.id).sort().join(','),
                completed: player.completedCards.map(c => c.id).sort().join(',')
            };

            if (currentSnapshot.active !== player.taurusSnapshot.active ||
                currentSnapshot.completed !== player.taurusSnapshot.completed) {

                const taurusId = player.taurusPendingId;
                forceForsakeCardById(playerId, taurusId, 'Taurus failed due to card loss');
                player.taurusPending = false;
                player.taurusPendingId = null;
                player.taurusSnapshot = null;
            }
        }

        function resolveOpponentScorpioOnCompletion(completingPlayerId) {
            const opponentId = completingPlayerId === 1 ? 2 : 1;
            const opponent = gameState.players[opponentId];

            const scorpioCards = opponent.activeCards.filter(c => c.name === 'Scorpio');
            scorpioCards.forEach(s => {
                forceForsakeCardById(opponentId, s.id, `Scorpio failed because opponent completed a challenge`);
            });
        }

        function runPostCardChangeChecks() {
            refillToThree(gameState, 1);
            refillToThree(gameState, 2);
            updateGameDisplay();
        }

        function attemptChallenge(playerId) {
            if (playerId !== gameState.currentPlayer) {
                showActionFeedback("It's not your turn!", false);
                return;
            }

            const player = gameState.players[playerId];

            if (!player.selectedCard) {
                showActionFeedback("Select a card first!", false);
                return;
            }

            const card = player.selectedCard;

            if (card.element === 'retrograde') {
                showActionFeedback("Retrograde cards cannot be attempted as challenges!", false);
                player.selectedCard = null;
                updateGameDisplay();
                return;
            }

            // Handle Scorpio special case
            if (card.name === "Scorpio" && card.challenge && card.challenge.includes("complete any active cards challenge")) {
                challengeSourceCard = card;
                openChallengeTargetModal();
                return;
            }

            // Auto-complete cards with no challenge
            if (!card.challenge || card.challenge.trim() === "") {
                showActionFeedback(`${card.name} auto-completed!`, true);
                player.completedCards.push(card);
                player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                player.selectedCard = null;

                resolveOpponentScorpioOnCompletion(gameState.currentPlayer);

                refillToThree(gameState, gameState.currentPlayer);
                runPostCardChangeChecks();
                checkWinCondition();
                endTurn();
                return;
            }

            // Handle special challenges
            if (card.name === "Capricorn") {
                openCapricornChoiceModal(card);
                return;
            }

            if (card.name === "Leo" && card.challenge.includes("predict")) {
                startPredictionChallenge(card);
                return;
            }

            if (card.name === "Cancer") {
                openCancerChoiceModal(card);
                return;
            }

            if (card.name === "Virgo") {
                openVirgoChoiceModal(card);
                return;
            }

            // For Taurus
            if (card.name === "Taurus") {
                player.taurusPending = true;
                player.taurusPendingId = card.id;
                player.taurusSnapshot = {
                    active: player.activeCards.map(c => c.id).sort().join(','),
                    completed: player.completedCards.map(c => c.id).sort().join(',')
                };

                showActionFeedback("Taurus: Keep your hand unchanged until your next turn to complete this card.", true);
                player.selectedCard = null;
                refillToThree(gameState, gameState.currentPlayer);
                updateGameDisplay();
                endTurn();
                return;
            }

            // For Libra
            if (card.name === "Libra") {
                if (hasAllElements(player)) {
                    showActionFeedback("Libra completed! You have all elements.", true);
                    player.completedCards.push(card);
                    player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                    resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
                } else {
                    showActionFeedback("Libra failed! You don't have all elements.", false);
                    if (countTotalCards(player) < 4) {
                        player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                        gameState.discardPile.push(card);
                        showActionFeedback("Libra disadvantage: card forsaken due to low card count.", false);
                    }
                }
                player.selectedCard = null;
                refillToThree(gameState, gameState.currentPlayer);
                runPostCardChangeChecks();
                checkWinCondition();
                endTurn();
                return;
            }

            // For other cards with standard challenges
            const success = confirm(`Attempt ${card.name} challenge?\n\n"${card.challenge}"\n\nClick OK if successful, Cancel if failed.`);

            if (success) {
                showActionFeedback(`Success: ${card.name}`, true);
                player.completedCards.push(card);
                player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
            } else {
                showActionFeedback(`Failed: ${card.name}`, false);
                if (player.activeCards.find(c => c.id === card.id)) {
                    player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                    gameState.discardPile.push(card);
                }
            }

            player.selectedCard = null;
            refillToThree(gameState, gameState.currentPlayer);
            runPostCardChangeChecks();
            checkWinCondition();
            endTurn();
        }

        function startPredictionChallenge(card) {
            const predictionHtml = `
                <div class="modal-overlay" id="prediction-modal" style="display: block;">
                    <div class="modal-content">
                        <button class="close-modal" id="close-prediction">&times;</button>
                        <h2 class="text-center mb-4" style="color: #e2e8ff;">Predict Next Card Element</h2>
                        <p style="color: #c2a8ff; text-align: center; margin-bottom: 20px;">
                            Predict the element of the next card in the deck:
                        </p>
                        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary prediction-choice" data-element="earth">Earth</button>
                            <button class="btn btn-primary prediction-choice" data-element="air">Air</button>
                            <button class="btn btn-primary prediction-choice" data-element="fire">Fire</button>
                            <button class="btn btn-primary prediction-choice" data-element="water">Water</button>
                        </div>
                        <div class="text-center mt-4">
                            <button class="btn btn-secondary" id="prediction-cancel">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', predictionHtml);

            const modal = document.getElementById('prediction-modal');
            const closeBtn = document.getElementById('close-prediction');
            const cancelBtn = document.getElementById('prediction-cancel');
            const choiceBtns = document.querySelectorAll('.prediction-choice');

            function cleanup() {
                modal.remove();
            }

            choiceBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const predictedElement = this.getAttribute('data-element');
                    resolveLeoPrediction(card, predictedElement);
                    cleanup();
                });
            });

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);

            modal.addEventListener('click', function(e) {
                if (e.target === modal) cleanup();
            });
        }

        function resolveLeoPrediction(card, predictedElement) {
            const player = gameState.players[gameState.currentPlayer];

            if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
            if (gameState.deck.length === 0) {
                showActionFeedback("Prediction failed: no cards in deck", false);
                return;
            }

            const nextCard = gameState.deck[gameState.deck.length - 1];
            const actualElement = nextCard.element;

            if (predictedElement === actualElement) {
                player.completedCards.push(card);
                player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                showActionFeedback(`Correct! Next card was ${actualElement}. ${card.name} completed!`, true);
                resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
            } else {
                const matchingCards = player.activeCards.filter(c => c.element === actualElement && c.id !== card.id);
                matchingCards.forEach(lostCard => {
                    player.activeCards = player.activeCards.filter(c => c.id !== lostCard.id);
                    gameState.discardPile.push(lostCard);
                });
                showActionFeedback(`Wrong! Next card was ${actualElement}. Lost ${matchingCards.length} ${actualElement} card(s).`, false);
            }

            player.selectedCard = null;
            refillToThree(gameState, gameState.currentPlayer);
            runPostCardChangeChecks();
            checkWinCondition();
            endTurn();
        }

        function openCapricornChoiceModal(card) {
            const player = gameState.players[gameState.currentPlayer];
            const fireCards = player.activeCards.filter(c => c.element === 'fire' && c.id !== card.id);

            const modalHtml = `
                <div class="modal-overlay" id="capricorn-choice-modal" style="display: block;">
                    <div class="modal-content">
                        <button class="close-modal" id="close-capricorn">&times;</button>
                        <h2 class="text-center mb-4" style="color: #e2e8ff;">Capricorn Challenge</h2>
                        <p style="color: #c2a8ff; text-align: center; margin-bottom: 20px;">
                            ${fireCards.length > 0 ? 
                                'Choose how to complete Capricorn:' : 
                                'No Fire cards to forsake. Try to draw an Earth card:'}
                        </p>
                        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                            ${fireCards.length > 0 ? 
                                `<button class="btn btn-primary" id="capricorn-forsake-fire">Forsake Fire Sign</button>` : 
                                ''}
                            <button class="btn btn-primary" id="capricorn-draw-earth">Try to Draw Earth</button>
                        </div>
                        <div class="text-center mt-4">
                            <button class="btn btn-secondary" id="capricorn-cancel">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);

            const modal = document.getElementById('capricorn-choice-modal');
            const closeBtn = document.getElementById('close-capricorn');
            const forsakeFireBtn = document.getElementById('capricorn-forsake-fire');
            const drawEarthBtn = document.getElementById('capricorn-draw-earth');
            const cancelBtn = document.getElementById('capricorn-cancel');

            function cleanup() {
                modal.remove();
            }

            if (forsakeFireBtn) {
                forsakeFireBtn.addEventListener('click', function() {
                    const player = gameState.players[gameState.currentPlayer];
                    if (fireCards.length > 0) {
                        const fireCard = fireCards[0];
                        player.activeCards = player.activeCards.filter(c => c.id !== fireCard.id);
                        gameState.discardPile.push(fireCard);

                        player.completedCards.push(card);
                        player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                        player.selectedCard = null;

                        resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
                        showActionFeedback('Capricorn success: forsook a Fire sign.', true);
                        cleanup();
                        refillToThree(gameState, gameState.currentPlayer);
                        runPostCardChangeChecks();
                        checkWinCondition();
                        endTurn();
                    }
                });
            }

            drawEarthBtn.addEventListener('click', function() {
                const player = gameState.players[gameState.currentPlayer];
                let foundEarth = false;

                for (let i = 0; i < 3; i++) {
                    if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
                    if (gameState.deck.length === 0) break;

                    const topCard = gameState.deck[gameState.deck.length - 1];
                    if (topCard.element === 'earth') {
                        const gained = gameState.deck.pop();
                        player.activeCards.push(gained);
                        showActionFeedback('Capricorn success: gained an Earth sign!', true);
                        foundEarth = true;

                        player.completedCards.push(card);
                        player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                        resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
                        break;
                    } else {
                        const discarded = gameState.deck.pop();
                        gameState.discardPile.push(discarded);
                    }
                }

                if (!foundEarth) {
                    showActionFeedback('Capricorn failed: No Earth sign found. Card forsaken.', false);
                    player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                    gameState.discardPile.push(card);
                }

                player.selectedCard = null;
                cleanup();
                refillToThree(gameState, gameState.currentPlayer);
                runPostCardChangeChecks();
                checkWinCondition();
                endTurn();
            });

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);

            modal.addEventListener('click', function(e) {
                if (e.target === modal) cleanup();
            });
        }

        function openCancerChoiceModal(card) {
            const player = gameState.players[gameState.currentPlayer];
            const availableCards = player.activeCards.filter(c => c.id !== card.id);

            if (availableCards.length === 0) {
                showActionFeedback('Cancer: no card available to offer.', false);
                return;
            }

            const modalHtml = `
                <div class="modal-overlay" id="cancer-choice-modal" style="display: block;">
                    <div class="modal-content">
                        <button class="close-modal" id="close-cancer">&times;</button>
                        <h2 class="text-center mb-4" style="color: #e2e8ff;">Cancer Challenge</h2>
                        <p style="color: #c2a8ff; text-align: center; margin-bottom: 20px;">
                            Select a card to offer to your opponent:
                        </p>
                        <div id="cancer-cards-container" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;"></div>
                        <div class="text-center mt-4">
                            <button class="btn btn-secondary" id="cancer-cancel">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modal = document.getElementById('cancer-choice-modal');
            const container = document.getElementById('cancer-cards-container');
            const closeBtn = document.getElementById('close-cancer');
            const cancelBtn = document.getElementById('cancer-cancel');

            function cleanup() {
                modal.remove();
            }

            availableCards.forEach(offerCard => {
                const cardEl = createCardElement(offerCard);
                cardEl.style.cursor = 'pointer';
                cardEl.addEventListener('click', function() {
                    gameState.tradeOffer = { 
                        from: gameState.currentPlayer, 
                        card: offerCard, 
                        isCancer: true,
                        cancerSourceCard: card
                    };
                    cleanup();
                    openTradeModalForOffer();
                });
                container.appendChild(cardEl);
            });

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);

            modal.addEventListener('click', function(e) {
                if (e.target === modal) cleanup();
            });
        }

        function openVirgoChoiceModal(card) {
            const player = gameState.players[gameState.currentPlayer];
            const otherCards = player.activeCards.filter(c => c.id !== card.id);

            if (otherCards.length < 2) {
                showActionFeedback('Virgo: Need at least 2 other cards to forsake.', false);
                return;
            }

            const modalHtml = `
                <div class="modal-overlay" id="virgo-choice-modal" style="display: block;">
                    <div class="modal-content">
                        <button class="close-modal" id="close-virgo">&times;</button>
                        <h2 class="text-center mb-4" style="color: #e2e8ff;">Virgo Challenge</h2>
                        <p style="color: #c2a8ff; text-align: center; margin-bottom: 20px;">
                            Select two cards to forsake (click to select/deselect):
                        </p>
                        <div id="virgo-cards-container" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;"></div>
                        <div class="text-center mt-4">
                            <button class="btn btn-primary" id="virgo-confirm" disabled>Confirm Selection</button>
                            <button class="btn btn-secondary" id="virgo-cancel">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modal = document.getElementById('virgo-choice-modal');
            const container = document.getElementById('virgo-cards-container');
            const confirmBtn = document.getElementById('virgo-confirm');
            const closeBtn = document.getElementById('close-virgo');
            const cancelBtn = document.getElementById('virgo-cancel');

            let selectedCards = [];

            function cleanup() {
                modal.remove();
            }

            function updateConfirmButton() {
                confirmBtn.disabled = selectedCards.length !== 2;
            }

            otherCards.forEach(virgoCard => {
                const cardEl = createCardElement(virgoCard);
                cardEl.style.cursor = 'pointer';
                cardEl.addEventListener('click', function() {
                    if (selectedCards.includes(virgoCard.id)) {
                        selectedCards = selectedCards.filter(id => id !== virgoCard.id);
                        cardEl.classList.remove('selected');
                    } else if (selectedCards.length < 2) {
                        selectedCards.push(virgoCard.id);
                        cardEl.classList.add('selected');
                    }
                    updateConfirmButton();
                });
                container.appendChild(cardEl);
            });

            confirmBtn.addEventListener('click', function() {
                if (selectedCards.length === 2) {
                    const player = gameState.players[gameState.currentPlayer];
                    const previousElements = otherCards.map(c => c.element);

                    // Remove selected cards
                    player.activeCards = player.activeCards.filter(c => !selectedCards.includes(c.id));
                    selectedCards.forEach(cardId => {
                        const cardToDiscard = otherCards.find(c => c.id === cardId);
                        if (cardToDiscard) gameState.discardPile.push(cardToDiscard);
                    });

                    // Auto-draw 2 new cards
                    let drawnCards = [];
                    for (let i = 0; i < 2; i++) {
                        if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
                        if (gameState.deck.length === 0) break;
                        const newCard = gameState.deck.pop();
                        player.activeCards.push(newCard);
                        drawnCards.push(newCard);
                    }

                    // Check disadvantage
                    const newElements = drawnCards.map(c => c.element);
                    let matchCount = 0;
                    previousElements.forEach(element => {
                        if (newElements.includes(element)) {
                            matchCount++;
                        }
                    });

                    if (matchCount >= 2 && player.completedCards.length > 0) {
                        const toDiscard = player.completedCards[0];
                        player.completedCards = player.completedCards.filter(c => c.id !== toDiscard.id);
                        gameState.discardPile.push(toDiscard);
                        showActionFeedback('Virgo completed but lost one completed card due to disadvantage.', true);
                    } else {
                        showActionFeedback('Virgo completed!', true);
                    }

                    // Complete Virgo card
                    player.completedCards.push(card);
                    player.activeCards = player.activeCards.filter(c => c.id !== card.id);
                    player.selectedCard = null;

                    resolveOpponentScorpioOnCompletion(gameState.currentPlayer);

                    cleanup();
                    refillToThree(gameState, gameState.currentPlayer);
                    runPostCardChangeChecks();
                    checkWinCondition();
                    endTurn();
                }
            });

            closeBtn.addEventListener('click', cleanup);
            cancelBtn.addEventListener('click', cleanup);

            modal.addEventListener('click', function(e) {
                if (e.target === modal) cleanup();
            });

            updateConfirmButton();
        }

        function openChallengeTargetModal() {
            const player = gameState.players[gameState.currentPlayer];
            const modal = document.getElementById('challenge-target-modal');
            const targetCardsContainer = document.getElementById('challenge-target-cards');

            targetCardsContainer.innerHTML = '';

            const validTargets = player.activeCards.filter(card => 
                card.id !== challengeSourceCard.id && 
                card.challenge && 
                card.challenge.trim() !== "" &&
                card.name !== "Scorpio"
            );

            validTargets.forEach(card => {
                const cardEl = createCardElement(card);
                cardEl.classList.add('target');
                cardEl.addEventListener('click', function() {
                    handleChallengeTargetSelection(card);
                });
                targetCardsContainer.appendChild(cardEl);
            });

            if (targetCardsContainer.children.length === 0) {
                targetCardsContainer.innerHTML = '<p style="color: #c2a8ff; text-align: center;">No other cards with challenges available.</p>';
            }

            modal.style.display = 'block';
        }

        function handleChallengeTargetSelection(targetCard) {
            const player = gameState.players[gameState.currentPlayer];
            const success = confirm(`Attempt ${targetCard.name} challenge?\n\n"${targetCard.challenge}"\n\nClick OK if successful, Cancel if failed.`);

            if (success) {
                showActionFeedback(`Challenge succeeded: ${targetCard.name}`, true);
                player.completedCards.push(targetCard);
                player.activeCards = player.activeCards.filter(c => c.id !== targetCard.id);

                player.completedCards.push(challengeSourceCard);
                player.activeCards = player.activeCards.filter(c => c.id !== challengeSourceCard.id);
                showActionFeedback(`${challengeSourceCard.name} also completed!`, true);

                resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
            } else {
                showActionFeedback(`Challenge failed: ${targetCard.name}`, false);
                if (player.activeCards.find(c => c.id === targetCard.id)) {
                    player.activeCards = player.activeCards.filter(c => c.id !== targetCard.id);
                    gameState.discardPile.push(targetCard);
                }

                if (challengeSourceCard.name === "Scorpio") {
                    showActionFeedback('Scorpio disadvantage: card forsaken.', false);
                    player.activeCards = player.activeCards.filter(c => c.id !== challengeSourceCard.id);
                    gameState.discardPile.push(challengeSourceCard);
                }
            }

            player.selectedCard = null;
            challengeSourceCard = null;
            closeChallengeTargetModal();
            refillToThree(gameState, gameState.currentPlayer);
            runPostCardChangeChecks();
            checkWinCondition();
            endTurn();
        }

        function closeChallengeTargetModal() {
            const modal = document.getElementById('challenge-target-modal');
            modal.style.display = 'none';
            challengeSourceCard = null;
        }

        function hasAllElements(player) {
            const elements = new Set();
            player.activeCards.concat(player.completedCards).forEach(card => {
                if (card.element && card.element !== 'retrograde') {
                    elements.add(card.element);
                }
            });
            return elements.size >= 4;
        }

        function countTotalCards(player) {
            return player.activeCards.length + player.completedCards.length;
        }

        function forsakeAndDraw(playerId) {
            if (playerId !== gameState.currentPlayer) {
                showActionFeedback("It's not your turn!", false);
                return;
            }

            const player = gameState.players[playerId];
            if (!player.selectedCard) {
                showActionFeedback("Please select a card to forsake first!", false);
                return;
            }
            const discardedCard = player.selectedCard;
            player.activeCards = player.activeCards.filter(c => c.id !== discardedCard.id);
            gameState.discardPile.push(discardedCard);

            if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
            if (gameState.deck.length === 0) {
                showActionFeedback("No cards left in the deck!", false);
            } else {
                const newCard = gameState.deck.pop();
                player.activeCards.push(newCard);
                showActionFeedback('You forsaked a card and drew a new one.', true);
            }

            player.selectedCard = null;
            refillToThree(gameState, gameState.currentPlayer);
            runPostCardChangeChecks();
            endTurn();
        }

        function drawFromDeck() {
            const player = gameState.players[gameState.currentPlayer];

            if (virgoState && virgoState.playerId === gameState.currentPlayer) {
                if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
                if (gameState.deck.length === 0) {
                    showActionFeedback("No cards left in the deck!", false);
                    return;
                }

                const newCard = gameState.deck.pop();
                player.activeCards.push(newCard);

                const currentActiveCount = player.activeCards.length;
                const cardsDrawn = currentActiveCount - (3 - virgoState.selectedCardIds.length);

                if (cardsDrawn < 2) {
                    showActionFeedback(`Virgo: Drew ${newCard.name}. Click deck again to draw second card.`, true);
                } else {
                    const newElements = player.activeCards.map(c => c.element);
                    let matchCount = 0;
                    virgoState.previousElements.forEach(element => {
                        if (newElements.includes(element)) {
                            matchCount++;
                        }
                    });

                    if (matchCount >= 2 && player.completedCards.length > 0) {
                        const toDiscard = player.completedCards[0];
                        player.completedCards = player.completedCards.filter(c => c.id !== toDiscard.id);
                        gameState.discardPile.push(toDiscard);
                        showActionFeedback('Virgo completed but lost one completed card due to disadvantage.', true);
                    } else {
                        showActionFeedback('Virgo completed!', true);
                    }

                    player.completedCards.push(virgoState.virgoCard);
                    player.activeCards = player.activeCards.filter(c => c.id !== virgoState.virgoCard.id);
                    player.selectedCard = null;

                    resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
                    virgoState = null;

                    refillToThree(gameState, gameState.currentPlayer);
                    runPostCardChangeChecks();
                    checkWinCondition();
                    endTurn();
                }
                updateGameDisplay();
                return;
            }

            if (gameState.deck.length === 0) reshuffleDiscardIntoDeck(gameState);
            if (gameState.deck.length === 0) {
                showActionFeedback("No cards left in the deck!", false);
                return;
            }
            const newCard = gameState.deck.pop();
            player.activeCards.push(newCard);
            showActionFeedback(`Drew ${newCard.name} from the deck`, true);
            refillToThree(gameState, gameState.currentPlayer);
            runPostCardChangeChecks();
            endTurn();
        }

        function useRetrograde(playerId) {
            if (playerId !== gameState.currentPlayer) {
                showActionFeedback("It's not your turn!", false);
                return;
            }

            const player = gameState.players[playerId];
            if (player.usedRetrograde) {
                showActionFeedback("You have already used your Retrograde this game!", false);
                return;
            }
            const p1 = gameState.players[1], p2 = gameState.players[2];
            const toReturn = [];

            p1.completedCards.forEach(c => toReturn.push(c));
            p2.completedCards.forEach(c => toReturn.push(c));

            p1.completedCards = [];
            p2.completedCards = [];

            gameState.deck.push(...toReturn);
            shuffleDeck(gameState.deck);

            player.usedRetrograde = true;
            showActionFeedback("Retrograde activated! All completed cards returned to deck.", true);
            refillToThree(gameState, 1);
            refillToThree(gameState, 2);

            runPostCardChangeChecks();
            endTurn();
        }

        function skipTurn(playerId) {
            if (playerId !== gameState.currentPlayer) {
                showActionFeedback("It's not your turn!", false);
                return;
            }

            showActionFeedback("Turn skipped", true);
            endTurn();
        }

        function initiateTrade(playerId) {
            if (playerId !== gameState.currentPlayer) {
                showActionFeedback("It's not your turn!", false);
                return;
            }

            const player = gameState.players[playerId];
            if (!player.selectedCard) {
                showActionFeedback("Select a card to offer in trade!", false);
                return;
            }
            gameState.tradeOffer = { from: playerId, card: player.selectedCard };
            openTradeModalForOffer();
        }

        function openTradeModalForOffer() {
            if (!gameState.tradeOffer) return;
            const fromId = gameState.tradeOffer.from;
            const offerCard = gameState.tradeOffer.card;
            const tradeOfferArea = document.getElementById('trade-offer-area');

            tradeOfferArea.innerHTML = '';
            const offerEl = createCardElement(offerCard);
            offerEl.classList.remove('hidden');
            tradeOfferArea.appendChild(offerEl);
            document.getElementById('trade-modal-title').textContent = `Player ${fromId} offers: ${offerCard.name}`;

            document.getElementById('trade-modal').style.display = 'block';
            document.getElementById('trade-select-responder').style.display = 'none';
            document.getElementById('trade-responder-cards').innerHTML = '';
        }

        function closeTradeModal() {
            gameState.tradeOffer = null;
            document.getElementById('trade-modal').style.display = 'none';
            document.getElementById('trade-offer-area').innerHTML = '';
            document.getElementById('trade-responder-cards').innerHTML = '';
        }

        function tradeAcceptHandler() {
            const offer = gameState.tradeOffer;
            if (!offer) return;
            const responderId = offer.from === 1 ? 2 : 1;
            const tradeSelectResponder = document.getElementById('trade-select-responder');
            const tradeResponderCards = document.getElementById('trade-responder-cards');

            tradeSelectResponder.style.display = 'block';
            tradeResponderCards.innerHTML = '';

            gameState.players[responderId].activeCards.forEach(card => {
                const clone = createCardElement(card);
                clone.classList.remove('hidden');
                clone.style.cursor = 'pointer';
                clone.addEventListener('click', function() {
                    performTradeSwap(offer.from, responderId, offer.card, card);

                    if (offer.isCancer && offer.cancerSourceCard) {
                        const cancerPlayer = gameState.players[offer.from];
                        cancerPlayer.completedCards.push(offer.cancerSourceCard);
                        cancerPlayer.activeCards = cancerPlayer.activeCards.filter(c => c.id !== offer.cancerSourceCard.id);
                        resolveOpponentScorpioOnCompletion(offer.from);
                        showActionFeedback('Cancer trade accepted! Cancer completed.', true);
                    }

                    closeTradeModal();
                    updateGameDisplay();
                    showActionFeedback('Trade completed!', true);
                    refillToThree(gameState, offer.from);
                    refillToThree(gameState, responderId);
                    runPostCardChangeChecks();
                    endTurn();
                });
                tradeResponderCards.appendChild(clone);
            });
        }

        function tradeDeclineHandler() {
            if (gameState.tradeOffer && gameState.tradeOffer.isCancer) {
                const from = gameState.tradeOffer.from;
                const player = gameState.players[from];

                const cancerCard = gameState.tradeOffer.cancerSourceCard;
                if (cancerCard) {
                    player.activeCards = player.activeCards.filter(c => c.id !== cancerCard.id);
                    gameState.discardPile.push(cancerCard);
                    showActionFeedback('Cancer challenge refused: Cancer card forsaken.', false);
                }
            }

            closeTradeModal();
        }

        function performTradeSwap(fromId, toId, fromCard, toCard) {
            const fromPlayer = gameState.players[fromId];
            const toPlayer = gameState.players[toId];
            fromPlayer.activeCards = fromPlayer.activeCards.filter(c => c.id !== fromCard.id);
            toPlayer.activeCards = toPlayer.activeCards.filter(c => c.id !== toCard.id);
            fromPlayer.activeCards.push(toCard);
            toPlayer.activeCards.push(fromCard);
            fromPlayer.selectedCard = null;
            toPlayer.selectedCard = null;

            runPostCardChangeChecks();
        }

        function cancelTrade() {
            if (gameState.tradeOffer) {
                gameState.players[gameState.tradeOffer.from].selectedCard = null;
            }
            closeTradeModal();
        }

        function endTurn() {
            runPostCardChangeChecks();

            setTimeout(() => {
                nextTurn();
            }, 900);
        }

        function nextTurn() {
            // Store the previous player before switching turns
            const previousPlayerId = gameState.currentPlayer;
            const previousPlayer = gameState.players[previousPlayerId];

            // Switch to next player
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

            // Now check if the NEW current player (the one who just started their turn) has Taurus pending
            const currentPlayer = gameState.players[gameState.currentPlayer];

            if (currentPlayer.taurusPending && currentPlayer.taurusPendingId) {
                const currentSnapshot = {
                    active: currentPlayer.activeCards.map(c => c.id).sort().join(','),
                    completed: currentPlayer.completedCards.map(c => c.id).sort().join(',')
                };

                if (currentSnapshot.active === currentPlayer.taurusSnapshot.active && 
                    currentSnapshot.completed === currentPlayer.taurusSnapshot.completed) {

                    // Taurus completed successfully - move to completed cards
                    const taurusCard = currentPlayer.activeCards.find(c => c.id === currentPlayer.taurusPendingId);
                    if (taurusCard) {
                        currentPlayer.activeCards = currentPlayer.activeCards.filter(c => c.id !== currentPlayer.taurusPendingId);
                        currentPlayer.completedCards.push(taurusCard);
                        showActionFeedback("Taurus completed - hand unchanged!", true);
                        resolveOpponentScorpioOnCompletion(gameState.currentPlayer);
                    }
                } else {
                    // Taurus failed - discard the card
                    currentPlayer.activeCards = currentPlayer.activeCards.filter(c => c.id !== currentPlayer.taurusPendingId);
                    const taurusCard = allCards.find(c => c.id === currentPlayer.taurusPendingId);
                    if (taurusCard) gameState.discardPile.push(taurusCard);
                    showActionFeedback("Taurus failed - hand was changed!", false);
                }

                // Reset Taurus state
                currentPlayer.taurusPending = false;
                currentPlayer.taurusPendingId = null;
                currentPlayer.taurusSnapshot = null;
            }

            const newPlayer = gameState.players[gameState.currentPlayer];
            if (newPlayer.skipNextTurn) {
                newPlayer.skipNextTurn = false;
                showActionFeedback(`Player ${gameState.currentPlayer} must skip this turn.`, false);
                endTurn();
                return;
            }

            gameState.players[1].selectedCard = null;
            gameState.players[2].selectedCard = null;

            refillToThree(gameState, gameState.currentPlayer);
            updateGameDisplay();
            runPostCardChangeChecks();
        }

        function checkWinCondition() {
            for (let p = 1; p <= 2; p++) {
                const player = gameState.players[p];
                const elementCounts = {};

                // Use a Set to track unique card names in completed cards
                const uniqueCompletedCards = [];
                const seenCardNames = new Set();

                player.completedCards.forEach(card => {
                    if (!seenCardNames.has(card.name)) {
                        seenCardNames.add(card.name);
                        uniqueCompletedCards.push(card);
                    }
                });

                // Count elements only from unique cards
                uniqueCompletedCards.forEach(card => {
                    if (card.element && card.element !== 'retrograde') {
                        elementCounts[card.element] = (elementCounts[card.element] || 0) + 1;
                        if (elementCounts[card.element] >= 3) {
                            const winnerModal = document.getElementById("winner-modal");
                            const winnerText = document.getElementById("winner-text");

                            winnerText.textContent = `Player ${p} Wins!`;
                            winnerModal.style.display = "block";
                            return true;
                        }
                    }
                });
            }
            return false;
        }

        // Initialize the game when page loads
        window.addEventListener('load', function() {
            initializeHamburgerMenu();
            initializeGame();
        });
    </script>
</body>
</html>